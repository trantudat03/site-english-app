I will refactor the frontend authentication system to support the Strapi v5 HttpOnly cookie flow.

### 1. New Core Modules
*   **`features/auth/tokenStore.ts`**: Create a lightweight singleton to manage the Access Token in memory.
*   **`features/auth/authApi.ts`**: Update to support the new endpoints:
    *   `login`: POST `/api/auth/local`
    *   `refreshToken`: POST `/api/auth/refresh` (with `credentials: 'include'`)
    *   `logout`: POST `/api/auth/logout` (with `credentials: 'include'`)

### 2. HTTP Client Refactoring (`features/api/strapiFetch.ts`)
*   **Interceptor Logic**: Rewrite `fetchWithAuth` to:
    1.  Attach Access Token from `tokenStore`.
    2.  Handle `401 Unauthorized` responses.
    3.  Trigger the refresh flow (using a mutex/queue to handle concurrent requests).
    4.  Retry the original request with the new token.
    5.  Redirect to `/login` if refresh fails.
*   **Configuration**: Ensure `credentials: 'include'` is set for auth-related requests to allow sending/receiving the HttpOnly cookie.

### 3. Auth Provider Update (`features/auth/AuthProvider.tsx`)
*   **Initialization**: On app mount, instead of reading from localStorage, it will attempt to silent refresh (`refreshToken()`).
    *   Success: User is authenticated, Access Token is set in memory.
    *   Failure: User is unauthenticated.
*   **State Management**: Sync React state (`user`, `status`) with the in-memory token store.

### 4. Cleanup & Integration
*   **`features/auth/storage.ts`**: Deprecate/Remove localStorage token logic.
*   **`features/auth/RequireAuth.tsx`**: Ensure it handles the initial "loading" state during the silent refresh check.
*   **Environment**: Verify `NEXT_PUBLIC_STRAPI_URL` usage for the base URL.

### 5. Verification
*   I will create a helper component or test logic to verify the flow:
    *   Login -> Check in-memory token.
    *   Reload Page -> Verify session is restored via silent refresh.
    *   Logout -> Verify session is cleared.
